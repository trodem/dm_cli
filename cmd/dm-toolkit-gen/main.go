package main

import (
	"bufio"
	"errors"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

var psFunctionLine = regexp.MustCompile(`(?i)^\s*function\s+([a-z0-9_-]+)\b`)

type stringList []string

func (s *stringList) String() string {
	return strings.Join(*s, ",")
}

func (s *stringList) Set(value string) error {
	v := strings.TrimSpace(value)
	if v == "" {
		return nil
	}
	*s = append(*s, v)
	return nil
}

func main() {
	if len(os.Args) < 2 {
		printUsage()
		os.Exit(2)
	}

	var err error
	switch os.Args[1] {
	case "init":
		err = runInit(os.Args[2:])
	case "add":
		err = runAdd(os.Args[2:])
	case "validate":
		err = runValidate(os.Args[2:])
	case "help", "-h", "--help":
		printUsage()
		return
	default:
		err = fmt.Errorf("unknown command: %s", os.Args[1])
	}

	if err != nil {
		fmt.Fprintln(os.Stderr, "error:", err)
		os.Exit(1)
	}
}

func printUsage() {
	fmt.Println("dm-toolkit-gen - scaffold and maintain dm PowerShell toolkits")
	fmt.Println("")
	fmt.Println("Usage:")
	fmt.Println("  dm-toolkit-gen init [flags]")
	fmt.Println("  dm-toolkit-gen add [flags]")
	fmt.Println("  dm-toolkit-gen validate [flags]")
	fmt.Println("")
	fmt.Println("Examples:")
	fmt.Println("  dm-toolkit-gen init --name MSWord --prefix word --category office")
	fmt.Println("  dm-toolkit-gen add --file plugins/functions/office/MSWord_Toolkit.ps1 --prefix word --func export_pdf --param InputPath --param OutputPath")
	fmt.Println("  dm-toolkit-gen add --file plugins/functions/STIBS/STIBS_DB_Toolkit.ps1 --prefix stibs_db --func restore --confirm --require-helper _confirm_action")
	fmt.Println("  dm-toolkit-gen validate")
}

func runInit(args []string) error {
	fs := flag.NewFlagSet("init", flag.ContinueOnError)
	fs.SetOutput(os.Stderr)

	var (
		repo       string
		name       string
		prefix     string
		category   string
		outFile    string
		desc       string
		forceWrite bool
	)

	fs.StringVar(&repo, "repo", "", "path to dm repository root (auto-detected if omitted)")
	fs.StringVar(&name, "name", "", "toolkit name (e.g. MSWord)")
	fs.StringVar(&prefix, "prefix", "", "public function prefix (e.g. word)")
	fs.StringVar(&category, "category", "", "subfolder under plugins/functions (optional)")
	fs.StringVar(&outFile, "file", "", "explicit output .ps1 file path")
	fs.StringVar(&desc, "description", "", "toolkit description")
	fs.BoolVar(&forceWrite, "force", false, "overwrite file if it already exists")
	if err := fs.Parse(args); err != nil {
		return err
	}

	if strings.TrimSpace(name) == "" {
		return errors.New("--name is required")
	}
	if strings.TrimSpace(prefix) == "" {
		return errors.New("--prefix is required")
	}
	if !isSafeToken(prefix) {
		return fmt.Errorf("invalid --prefix %q, use letters/numbers/underscore", prefix)
	}
	repoRoot, err := resolveRepoRoot(repo)
	if err != nil {
		return err
	}

	target := strings.TrimSpace(outFile)
	if target == "" {
		filename := sanitizeTitle(name) + "_Toolkit.ps1"
		baseDir := filepath.Join(repoRoot, "plugins", "functions")
		if strings.TrimSpace(category) != "" {
			baseDir = filepath.Join(baseDir, category)
		}
		target = filepath.Join(baseDir, filename)
	} else if !filepath.IsAbs(target) {
		target = filepath.Join(repoRoot, target)
	}

	if err := os.MkdirAll(filepath.Dir(target), 0o755); err != nil {
		return err
	}
	if !forceWrite {
		if _, statErr := os.Stat(target); statErr == nil {
			return fmt.Errorf("file already exists: %s (use --force to overwrite)", target)
		}
	}

	if strings.TrimSpace(desc) == "" {
		desc = fmt.Sprintf("%s toolkit generated by dm-toolkit-gen", sanitizeTitle(name))
	}
	initialFunction := strings.ToLower(prefix) + "_info"
	content := renderToolkitFile(sanitizeTitle(name), strings.ToLower(prefix), desc, initialFunction)
	if err := os.WriteFile(target, []byte(content), 0o644); err != nil {
		return err
	}

	rel := toRel(repoRoot, target)
	fmt.Printf("created toolkit: %s\n", rel)
	return nil
}

func runAdd(args []string) error {
	fs := flag.NewFlagSet("add", flag.ContinueOnError)
	fs.SetOutput(os.Stderr)

	var (
		repo           string
		filePath       string
		prefix         string
		funcName       string
		synopsis       string
		description    string
		confirmAction  bool
		requireVars    stringList
		requireHelpers stringList
		params         stringList
		switches       stringList
	)

	fs.StringVar(&repo, "repo", "", "path to dm repository root (auto-detected if omitted)")
	fs.StringVar(&filePath, "file", "", "target toolkit .ps1 path")
	fs.StringVar(&prefix, "prefix", "", "function prefix (e.g. word)")
	fs.StringVar(&funcName, "func", "", "function suffix (e.g. export_pdf)")
	fs.StringVar(&synopsis, "synopsis", "", "help synopsis")
	fs.StringVar(&description, "description", "", "help description")
	fs.BoolVar(&confirmAction, "confirm", false, "add -Force confirmation guard with _confirm_action")
	fs.Var(&requireVars, "require-var", "ensure variable in plugins/variables.ps1, format NAME=default")
	fs.Var(&requireHelpers, "require-helper", "ensure helper in plugins/utils.ps1")
	fs.Var(&params, "param", "mandatory string parameter name (repeatable)")
	fs.Var(&switches, "switch", "switch parameter name (repeatable)")
	if err := fs.Parse(args); err != nil {
		return err
	}

	if strings.TrimSpace(filePath) == "" {
		return errors.New("--file is required")
	}
	if strings.TrimSpace(prefix) == "" {
		return errors.New("--prefix is required")
	}
	if strings.TrimSpace(funcName) == "" {
		return errors.New("--func is required")
	}
	if !isSafeToken(prefix) || !isSafeToken(funcName) {
		return errors.New("--prefix and --func must use letters/numbers/underscore")
	}

	repoRoot, err := resolveRepoRoot(repo)
	if err != nil {
		return err
	}
	target := filePath
	if !filepath.IsAbs(target) {
		target = filepath.Join(repoRoot, target)
	}

	data, err := os.ReadFile(target)
	if err != nil {
		return err
	}
	text := string(data)

	publicFn := strings.ToLower(prefix) + "_" + strings.ToLower(funcName)
	if functionExists(text, publicFn) {
		return fmt.Errorf("function already exists: %s", publicFn)
	}

	if confirmAction && !containsToken(requireHelpers, "_confirm_action") {
		requireHelpers = append(requireHelpers, "_confirm_action")
	}

	for _, h := range requireHelpers {
		if err := ensureHelper(repoRoot, strings.TrimSpace(h)); err != nil {
			return err
		}
	}
	for _, v := range requireVars {
		name, def, parseErr := parseVarSpec(v)
		if parseErr != nil {
			return parseErr
		}
		if err := ensureVariable(repoRoot, name, def); err != nil {
			return err
		}
	}

	block := renderFunctionBlock(publicFn, synopsis, description, params, switches, confirmAction)
	if !strings.HasSuffix(text, "\n") {
		text += "\n"
	}
	text += "\n" + block
	if err := os.WriteFile(target, []byte(text), 0o644); err != nil {
		return err
	}

	fmt.Printf("added function: %s -> %s\n", publicFn, toRel(repoRoot, target))
	return nil
}

func runValidate(args []string) error {
	fs := flag.NewFlagSet("validate", flag.ContinueOnError)
	fs.SetOutput(os.Stderr)

	var repo string
	fs.StringVar(&repo, "repo", "", "path to dm repository root (auto-detected if omitted)")
	if err := fs.Parse(args); err != nil {
		return err
	}

	repoRoot, err := resolveRepoRoot(repo)
	if err != nil {
		return err
	}
	functionsDir := filepath.Join(repoRoot, "plugins", "functions")
	files, err := listPSFiles(functionsDir)
	if err != nil {
		return err
	}

	type issue struct {
		path string
		line int
		msg  string
	}
	var issues []issue
	seen := map[string]string{}
	totalFns := 0

	for _, file := range files {
		lines, err := readLines(file)
		if err != nil {
			issues = append(issues, issue{path: file, line: 1, msg: err.Error()})
			continue
		}
		hasStrict := false
		hasStop := false
		for _, line := range lines {
			trim := strings.TrimSpace(strings.ToLower(line))
			if trim == "set-strictmode -version latest" {
				hasStrict = true
			}
			if strings.Contains(trim, "$erroractionpreference") && strings.Contains(trim, "stop") {
				hasStop = true
			}
		}
		if !hasStrict {
			issues = append(issues, issue{path: file, line: 1, msg: "missing Set-StrictMode -Version Latest"})
		}
		if !hasStop {
			issues = append(issues, issue{path: file, line: 1, msg: "missing $ErrorActionPreference = \"Stop\""})
		}

		for i, line := range lines {
			m := psFunctionLine.FindStringSubmatch(line)
			if len(m) != 2 {
				continue
			}
			fn := strings.TrimSpace(m[1])
			totalFns++

			j := i - 1
			for j >= 0 && strings.TrimSpace(lines[j]) == "" {
				j--
			}
			if j < 0 || strings.TrimSpace(lines[j]) != "#>" {
				issues = append(issues, issue{path: file, line: i + 1, msg: "missing comment-based help block before function"})
			}

			if strings.HasPrefix(fn, "_") {
				continue
			}
			if prev, ok := seen[strings.ToLower(fn)]; ok {
				issues = append(issues, issue{path: file, line: i + 1, msg: fmt.Sprintf("duplicate public function '%s' (already in %s)", fn, toRel(repoRoot, prev))})
				continue
			}
			seen[strings.ToLower(fn)] = file
		}
	}

	sort.Slice(issues, func(i, j int) bool {
		if issues[i].path == issues[j].path {
			return issues[i].line < issues[j].line
		}
		return issues[i].path < issues[j].path
	})

	if len(issues) > 0 {
		for _, it := range issues {
			fmt.Fprintf(os.Stderr, "%s:%d: %s\n", toRel(repoRoot, it.path), it.line, it.msg)
		}
		return fmt.Errorf("validation failed with %d issue(s)", len(issues))
	}

	fmt.Printf("OK: %d file(s), %d function(s), no validation issues\n", len(files), totalFns)
	return nil
}

func renderToolkitFile(name, prefix, description, initialFn string) string {
	return strings.Join([]string{
		"# =============================================================================",
		fmt.Sprintf("# %s TOOLKIT - %s", strings.ToUpper(name), description),
		"# Generated by dm-toolkit-gen",
		"# Entry point: " + prefix + "_*",
		"#",
		"# FUNCTIONS",
		"#   " + initialFn,
		"# =============================================================================",
		"",
		"Set-StrictMode -Version Latest",
		`$ErrorActionPreference = "Stop"`,
		"",
		"<#",
		".SYNOPSIS",
		"Show toolkit information.",
		".DESCRIPTION",
		"Starter function generated by dm-toolkit-gen.",
		".EXAMPLE",
		"dm " + initialFn,
		"#>",
		"function " + initialFn + " {",
		"    [pscustomobject]@{",
		"        Toolkit = " + quotePS(name),
		"        Prefix  = " + quotePS(prefix),
		"        Status  = " + quotePS("ready"),
		"    }",
		"}",
		"",
	}, "\n")
}

func renderFunctionBlock(name, synopsis, description string, params, switches []string, withConfirm bool) string {
	if strings.TrimSpace(synopsis) == "" {
		synopsis = "Invoke " + name + "."
	}
	if strings.TrimSpace(description) == "" {
		description = "Generated function scaffold."
	}

	lines := []string{
		"<#",
		".SYNOPSIS",
		synopsis,
		".DESCRIPTION",
		description,
	}
	for _, p := range params {
		pp := strings.TrimSpace(p)
		if pp == "" {
			continue
		}
		lines = append(lines, ".PARAMETER "+pp, "Parameter "+pp+".")
	}
	for _, s := range switches {
		ss := strings.TrimSpace(s)
		if ss == "" {
			continue
		}
		lines = append(lines, ".PARAMETER "+ss, "Switch "+ss+".")
	}
	if withConfirm {
		lines = append(lines, ".PARAMETER Force", "Skip interactive confirmation.")
	}
	lines = append(lines, ".EXAMPLE", "dm "+name, "#>")
	lines = append(lines, "function "+name+" {")

	var paramLines []string
	for _, p := range params {
		pp := strings.TrimSpace(p)
		if pp == "" {
			continue
		}
		paramLines = append(paramLines, "        [Parameter(Mandatory = $true)][string]$"+pp)
	}
	for _, s := range switches {
		ss := strings.TrimSpace(s)
		if ss == "" {
			continue
		}
		paramLines = append(paramLines, "        [switch]$"+ss)
	}
	if withConfirm {
		paramLines = append(paramLines, "        [switch]$Force")
	}
	if len(paramLines) > 0 {
		lines = append(lines, "    param(")
		for i, pl := range paramLines {
			if i < len(paramLines)-1 {
				lines = append(lines, pl+",")
			} else {
				lines = append(lines, pl)
			}
		}
		lines = append(lines, "    )", "")
	}

	if withConfirm {
		lines = append(lines,
			"    if (-not $Force) {",
			"        if (-not (_confirm_action -Prompt "+quotePS("Continue with "+name+"?")+")) {",
			"            Write-Output "+quotePS("Operation cancelled."),
			"            return",
			"        }",
			"    }",
			"",
		)
	}

	lines = append(lines,
		"    Write-Output "+quotePS("TODO: implement "+name),
		"}",
	)
	return strings.Join(lines, "\n")
}

func resolveRepoRoot(flagValue string) (string, error) {
	if strings.TrimSpace(flagValue) != "" {
		p, err := filepath.Abs(flagValue)
		if err != nil {
			return "", err
		}
		if !looksLikeRepoRoot(p) {
			return "", fmt.Errorf("invalid --repo, expected plugins/functions in %s", p)
		}
		return p, nil
	}

	cwd, _ := os.Getwd()
	if cwd != "" {
		if root, ok := findRepoUpwards(cwd); ok {
			return root, nil
		}
	}
	exe, err := os.Executable()
	if err == nil && strings.TrimSpace(exe) != "" {
		if root, ok := findRepoUpwards(filepath.Dir(exe)); ok {
			return root, nil
		}
	}
	return "", errors.New("could not auto-detect repo root (use --repo)")
}

func findRepoUpwards(start string) (string, bool) {
	cur := start
	for i := 0; i < 8; i++ {
		if looksLikeRepoRoot(cur) {
			return cur, true
		}
		parent := filepath.Dir(cur)
		if parent == cur {
			break
		}
		cur = parent
	}
	return "", false
}

func looksLikeRepoRoot(path string) bool {
	info, err := os.Stat(filepath.Join(path, "plugins", "functions"))
	return err == nil && info.IsDir()
}

func isSafeToken(v string) bool {
	ok, _ := regexp.MatchString(`^[A-Za-z0-9_]+$`, strings.TrimSpace(v))
	return ok
}

func sanitizeTitle(v string) string {
	s := strings.TrimSpace(v)
	if s == "" {
		return "Toolkit"
	}
	var b strings.Builder
	for _, r := range s {
		if (r >= 'A' && r <= 'Z') || (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') || r == '_' || r == '-' {
			b.WriteRune(r)
		}
	}
	out := b.String()
	if out == "" {
		return "Toolkit"
	}
	return out
}

func functionExists(text, functionName string) bool {
	re := regexp.MustCompile(`(?im)^\s*function\s+` + regexp.QuoteMeta(functionName) + `\b`)
	return re.FindStringIndex(text) != nil
}

func containsToken(list []string, token string) bool {
	t := strings.ToLower(strings.TrimSpace(token))
	for _, item := range list {
		if strings.ToLower(strings.TrimSpace(item)) == t {
			return true
		}
	}
	return false
}

func parseVarSpec(spec string) (string, string, error) {
	parts := strings.SplitN(spec, "=", 2)
	if len(parts) != 2 {
		return "", "", fmt.Errorf("invalid --require-var %q, use NAME=default", spec)
	}
	name := strings.TrimSpace(parts[0])
	def := strings.TrimSpace(parts[1])
	if !isSafeToken(name) {
		return "", "", fmt.Errorf("invalid variable name %q", name)
	}
	return name, def, nil
}

func ensureHelper(repoRoot, helperName string) error {
	path := filepath.Join(repoRoot, "plugins", "utils.ps1")
	content, err := readOrInitSharedPS(path)
	if err != nil {
		return err
	}
	if functionExists(content, helperName) {
		return nil
	}
	block, ok := helperTemplates()[helperName]
	if !ok {
		return fmt.Errorf("unknown helper template: %s", helperName)
	}
	if !strings.HasSuffix(content, "\n") {
		content += "\n"
	}
	content += "\n" + block + "\n"
	return os.WriteFile(path, []byte(content), 0o644)
}

func ensureVariable(repoRoot, name, defaultValue string) error {
	path := filepath.Join(repoRoot, "plugins", "variables.ps1")
	content, err := readOrInitSharedPS(path)
	if err != nil {
		return err
	}

	if !functionExists(content, "_env_or_default") {
		if !strings.HasSuffix(content, "\n") {
			content += "\n"
		}
		content += "\n" + envOrDefaultBlock() + "\n"
	}
	assignRe := regexp.MustCompile(`(?im)^\s*\$script:` + regexp.QuoteMeta(name) + `\s*=`)
	if assignRe.FindStringIndex(content) != nil {
		return os.WriteFile(path, []byte(content), 0o644)
	}

	begin := "# region dm-toolkit-gen:variables"
	end := "# endregion dm-toolkit-gen:variables"
	region := begin + "\n" + end
	if !strings.Contains(content, begin) || !strings.Contains(content, end) {
		if !strings.HasSuffix(content, "\n") {
			content += "\n"
		}
		content += "\n" + region + "\n"
	}

	assign := strings.Join([]string{
		"$script:" + name + " = _env_or_default `",
		"    -Name " + quotePS(name) + " `",
		"    -Default " + quotePS(defaultValue),
	}, "\n")
	content = strings.Replace(content, begin+"\n", begin+"\n"+assign+"\n\n", 1)
	return os.WriteFile(path, []byte(content), 0o644)
}

func readOrInitSharedPS(path string) (string, error) {
	data, err := os.ReadFile(path)
	if err == nil {
		return string(data), nil
	}
	if !os.IsNotExist(err) {
		return "", err
	}
	base := strings.Join([]string{
		"Set-StrictMode -Version Latest",
		`$ErrorActionPreference = "Stop"`,
		"",
	}, "\n")
	if mkErr := os.MkdirAll(filepath.Dir(path), 0o755); mkErr != nil {
		return "", mkErr
	}
	if writeErr := os.WriteFile(path, []byte(base), 0o644); writeErr != nil {
		return "", writeErr
	}
	return base, nil
}

func envOrDefaultBlock() string {
	return strings.Join([]string{
		"<#",
		".SYNOPSIS",
		"Resolve environment variable with fallback default.",
		".PARAMETER Name",
		"Environment variable name.",
		".PARAMETER Default",
		"Fallback value when env var is empty.",
		".EXAMPLE",
		"_env_or_default -Name \"DM_EXAMPLE\" -Default \"value\"",
		"#>",
		"function _env_or_default {",
		"    param(",
		"        [Parameter(Mandatory = $true)][string]$Name,",
		"        [Parameter(Mandatory = $true)][string]$Default",
		"    )",
		"",
		"    $value = [Environment]::GetEnvironmentVariable($Name)",
		"    if ([string]::IsNullOrWhiteSpace($value)) {",
		"        return $Default",
		"    }",
		"    return $value",
		"}",
	}, "\n")
}

func helperTemplates() map[string]string {
	return map[string]string{
		"_assert_command_available": strings.Join([]string{
			"<#",
			".SYNOPSIS",
			"Ensure a command is available in PATH.",
			".PARAMETER Name",
			"Executable/command name.",
			".EXAMPLE",
			"_assert_command_available -Name docker",
			"#>",
			"function _assert_command_available {",
			"    param([Parameter(Mandatory = $true)][string]$Name)",
			"    if (-not (Get-Command -Name $Name -ErrorAction SilentlyContinue)) {",
			"        throw \"Required command '$Name' was not found in PATH.\"",
			"    }",
			"}",
		}, "\n"),
		"_assert_path_exists": strings.Join([]string{
			"<#",
			".SYNOPSIS",
			"Ensure a filesystem path exists.",
			".PARAMETER Path",
			"Filesystem path to validate.",
			".EXAMPLE",
			"_assert_path_exists -Path C:\\temp",
			"#>",
			"function _assert_path_exists {",
			"    param([Parameter(Mandatory = $true)][string]$Path)",
			"    if (-not (Test-Path -LiteralPath $Path)) {",
			"        throw \"Required path '$Path' does not exist.\"",
			"    }",
			"}",
		}, "\n"),
		"_confirm_action": strings.Join([]string{
			"<#",
			".SYNOPSIS",
			"Ask for a yes/no confirmation before a risky action.",
			".PARAMETER Prompt",
			"Message shown to the user.",
			".EXAMPLE",
			"if (-not (_confirm_action -Prompt \"Continue?\")) { return }",
			"#>",
			"function _confirm_action {",
			"    param([Parameter(Mandatory = $true)][string]$Prompt)",
			"    $answer = Read-Host \"$Prompt [y/N]\"",
			"    if ([string]::IsNullOrWhiteSpace($answer)) {",
			"        return $false",
			"    }",
			"    return $answer.Trim().ToLowerInvariant() -in @(\"y\", \"yes\")",
			"}",
		}, "\n"),
	}
}

func listPSFiles(root string) ([]string, error) {
	var files []string
	err := filepath.WalkDir(root, func(path string, d os.DirEntry, walkErr error) error {
		if walkErr != nil {
			return walkErr
		}
		if d.IsDir() {
			return nil
		}
		ext := strings.ToLower(filepath.Ext(d.Name()))
		if ext == ".ps1" || ext == ".psm1" || ext == ".txt" {
			files = append(files, path)
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	sort.Strings(files)
	return files, nil
}

func readLines(path string) ([]string, error) {
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer f.Close()

	var out []string
	sc := bufio.NewScanner(f)
	for sc.Scan() {
		out = append(out, sc.Text())
	}
	if err := sc.Err(); err != nil {
		return nil, err
	}
	return out, nil
}

func quotePS(v string) string {
	return "'" + strings.ReplaceAll(v, "'", "''") + "'"
}

func toRel(root, path string) string {
	rel, err := filepath.Rel(root, path)
	if err != nil {
		return path
	}
	return rel
}
